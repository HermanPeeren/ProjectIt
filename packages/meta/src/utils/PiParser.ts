import * as fs from "fs";
import { Checker } from "./Checker";
import { Parser } from "pegjs";
import { PiLogger } from "../../../core/src/util/PiLogging";

const LOGGER = new PiLogger("PiParser").mute();

// the following two type are used to store the location information from the parser
export type ParseLocation = {
    start: Location;
    end: Location;
};

export type Location = {
    offset: number;
    line: number;
    column: number;
};

/**
 * Generic Parser, subclasses need to initialize the parser, checker and msg fields.
 */
export class PiParser<DEFINITION> {
    // No known type, as this is a Javascript parser object generated by pegjs.
    parser: Parser;
    checker: Checker<DEFINITION>;
    // msg: string;

    parse(definitionFile: string): DEFINITION {
        // Check language file
        if (!fs.existsSync(definitionFile)) {
            LOGGER.error(this, "definition file '" + definitionFile + "' does not exist, exiting.");
            throw new Error("file not found.");
        }
        const langSpec: string = fs.readFileSync(definitionFile, { encoding: "UTF8" });
        // Parse Language file
        let model: DEFINITION = null;
        try {
            model = this.parser.parse(langSpec);
        } catch (e) {
            // syntax error
            let errorstr = `${e} ${e.location && e.location.start ? `[line ${e.location.start.line}, column ${e.location.start.column}]` : ``}`;
            LOGGER.error(this, errorstr);
            throw new Error("syntax error.");
        }
        if (model !== null) {
            this.checker.check(model);
            if (this.checker.hasErrors()) {
                this.checker.errors.forEach(error => LOGGER.error(this, error));
                throw new Error("checking errors."); // error message
            }
            return model;
        } else {
            throw new Error("parser does not return a language definition.");
        }
    }
}
